/*** Licensed under the KARMA v.1 Law of Sharing. As others have shared freely to you, so shall you share freely back to us.* If you shall try to cheat and find a loophole in this license, then KARMA will exact your share,* and your worldly gain shall come to naught and those who share shall gain eventually above you.* In compliance with previous GPLv2.0 works of Jorg Janke, Low Heng Sin, Carlos Ruiz and contributors.* This Module Creator is an idea put together and coded by Redhuan D. Oon (red1@red1.org)*/package org.ninja.utils;
import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStreamReader;import java.math.BigDecimal;import java.sql.Timestamp;import java.util.ArrayList;import java.util.Arrays;import java.util.logging.Level;import org.adempiere.exceptions.AdempiereException;import org.adempiere.exceptions.DBException;import org.adempiere.pipo2.Zipper;import org.compiere.model.*;import org.compiere.tools.FileUtil;import org.compiere.util.AdempiereSystemError;import org.compiere.util.CLogger;import org.compiere.util.DB;import org.compiere.util.Env;import org.ninja.model.MRO_ModelHeader;import org.ninja.model.MRO_ModelMaker;	/**	 * Reuse ModelMaker set - parse CSV elements into ColumnSet.	 * @author red1	 *	 */	public class HandleCSVImport {
	private String trxName;	/**	Logger			*/	private static CLogger	log	= CLogger.getCLogger (HandleCSVImport.class);	MRO_ModelMaker m = null;		/**	 * Main constructor called by GenerateModule	 * @param maker	 */	public HandleCSVImport(MRO_ModelMaker maker){		m = maker;		trxName = maker.get_TrxName();	}	/**	 * For external use	 * @return	 * @throws Exception	 */	public String getCSVandProcess() throws Exception{		String attachment = getAttachment();		if (attachment.length()>0)			return "";		if (filename.toString().endsWith("zip"))			return handleBulkCSV();		else			return processCSV(); 	}		/**	 * Only for Migration of Master Data to Core Models	 * @return	 */	private String handleBulkCSV() {		String targetDirName = "AdempiereHome" + File.separator + "user" + Env.getContext(Env.getCtx(), "#AD_User_ID");		File targetDir = new File(targetDirName);		if (targetDir.exists()) {			try {				if (!FileUtil.deleteFolderRecursive(targetDir)) {					throw new AdempiereSystemError("Could not delete folder " + targetDirName + ", please check permissions");				}			} catch (FileNotFoundException e) { 				e.printStackTrace();			} catch (AdempiereSystemError e) { 				e.printStackTrace();			}		}		if (!targetDir.exists()) {			boolean success = targetDir.mkdirs();			if (!success) {				log.warning("Failed to create target directory. " + targetDirName);			}		}		int cnt=0;		// Unzip package 		if (log.isLoggable(Level.INFO)) log.info("zipFilepath->" + filename); 		Zipper.unpackFile(filename, targetDir);				File[] files = targetDir.listFiles();		Arrays.sort(files);			for (File file : files) {		    if (!file.isFile()) continue;		    			    cnt =+ bulkMigration(file);		    		}		m.setDescription("Bulk CSVs in ZIP file successfully imported - New Records: "+ cnt);		m.setIsActive(false);		m.saveEx(trxName);		return "CSV Bulk Processed";	} 		private String processCSV() throws FileNotFoundException {		ArrayList <String> SQLcols = new ArrayList<String>();		model = m.getName().toUpperCase();		BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));		try {			String line = in.readLine(); 			while (line.isEmpty() || line.matches(",+") || line.matches("\n"))				line = in.readLine();						String[] elements = null;			if (line.contains(quotes)){				elements = splitUp(line);			}			else elements = line.split(comma);				if (elements.length<2) throw new AdempiereException("NO comma separated values");						if (m.getColumnSet()==null || m.getColumnSet().isEmpty())	{				//put elements in ColumnSet if ColumnSet is blank/new				for (String element:elements){					String checked = element.replaceAll("\\s+", "");															if (element.toUpperCase().contains("DATE"))						checked = "D#"+element;					else if (element.toUpperCase().contains("QTY"))						checked = "Q#"+element;					else if (element.toUpperCase().contains("AMOUNT"))						checked = "A#"+element;					else if (element.startsWith("Is") || element.startsWith("In"))						checked = "Y#"+element;					else if (element.endsWith("_ID"))						checked = element; 					else if (element.contains("/") && element.contains("="))						checked = "L#"+element;										String buffer = m.getColumnSet();					if (buffer!=null)						buffer = buffer + comma;					else buffer = "";										m.setColumnSet(buffer+checked); 					}		  	}			//execute as ModelMaker			MMenu menu = m.handleModel();			if (menu==null){				;			} else {								//get menu and attach to Main tree 					attachMenuTree(menu);						}		  	//populate columnSet for Data Insert			//in > and = elements, take before those as column name for SQL insert statement 					  	for (String element:elements){		  				  		String[] sqlcol = element.split(">");				if (sqlcol.length>1){					SQLcols.add(sqlcol[0]);					continue;				}				sqlcol = element.split("=");				if (sqlcol.length>1){					SQLcols.add(sqlcol[0]);					continue;				}											SQLcols.add(element);	  						  	} 		  			m.setDescription("*ATTACHED CSV IMPORTING,");			m.saveEx(trxName);			int cnt = 0;							cnt = everyLineUpdateInsert(SQLcols, in, cnt);						m.setDescription(m.getDescription()+" RECORDS INSERTED: "+cnt+" RECORDS UPDATED: "+updated);			m.setIsActive(false);			m.saveEx(trxName);						return "CSV Import Counter: "+cnt;		 		} catch (FileNotFoundException e) {		        e.printStackTrace();		 } catch (IOException e) {		        e.printStackTrace();		 } finally {		        if (in != null) {		            try {		                in.close();		            } catch (IOException e) {		                e.printStackTrace();;		            }		        }		    }		return "";	}	/**	 * For Master Data Migration Only 	 * @param file	 */	private int bulkMigration(File file){		model = file.getName(); 		if (model.endsWith("-Table 1.csv"))			model = model.substring(2,model.length()-12);		else			model = model.substring(2,model.length()-4);		ArrayList <String> SQLcols = new ArrayList<String>();		BufferedReader in = null;		try {			in = new BufferedReader(new InputStreamReader(new FileInputStream(file)));			String line = in.readLine(); 			while (line.isEmpty() || line.matches(",+") || line.matches("\n"))				line = in.readLine();			String[] elements = null;			if (line.contains(quotes)){				elements = splitUp(line);			}			else elements = line.split(comma);						if (elements.length<2) 				throw new AdempiereException("NO comma separated values");			for (String col:elements){				if (col.length()>0){					MColumn column = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?)",trxName)							.setParameters(col.trim())							.first();					if (column==null)						log.warning(model+" HAS NO SUCH CORE MODEL COLUMN: "+col);										SQLcols.add(col);				}			}			int cnt = 0;				return everyLineUpdateInsert(SQLcols, in, cnt);					}catch (FileNotFoundException e) {	        e.printStackTrace();		} catch (IOException e) {	        e.printStackTrace();		} finally {	        if (in != null) {	            try {	                in.close();	            } catch (IOException e) {	                e.printStackTrace();	            }	        }	    }		return linecnt;	}	private String[] splitUp(String line) {		String[] elements = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", -1); 			for (int i=0;i<elements.length;i++){				String buffer = elements[i].replace("\"", "");				if (buffer.endsWith(" "))					buffer = buffer.substring(0, buffer.length()-1);				elements[i] = buffer; 							}		return elements;	}		private String model = "";
	private final String comma = ",";	private final String quotes = "\"";	File filename = null;	int updated = 0;	int rec_id = 0;	int linecnt=0;  	private int everyLineUpdateInsert(ArrayList<String> SQLcols, BufferedReader in, int cnt) throws IOException {		String line;		updated = 0;		if (model==null)			throw new AdempiereException("ModleMaker Name is null");		rec_id = DB.getSQLValue(trxName, "SELECT count(*) FROM "+model);		String REC_ID = Integer.toString(rec_id);		MSequence seq = null;		MTable tableHasSequence = new Query(Env.getCtx(),MTable.Table_Name,"UPPER("+MTable.COLUMNNAME_TableName+")=UPPER(?)",trxName)				.setParameters(model).first();				//new PO .. user ModelFactory Constructor		PO po =null;  		Class<? extends PO> clazz = null;		if (tableHasSequence!=null){			clazz = tableHasSequence.getClass();			seq = MSequence.get(Env.getCtx(), model);			if (seq!=null)				REC_ID = "nextIDFunc("+seq.getAD_Sequence_ID()+", 'N') ";		}		 		while ((line = in.readLine()) != null) {			if (line.isEmpty() || line.matches(",+") || line.matches("\n"))				continue;			log.fine(line);				linecnt++;			rec_id++;			if (seq==null)				REC_ID = Integer.toString(rec_id);			MColumn colname = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?) AND "+MColumn.COLUMNNAME_AD_Table_ID+"=?",trxName)					.setParameters(model+"_ID",tableHasSequence.get_ID())					.first();			if (colname==null)				log.fine(model+"_ID NOT THERE BUT STILL OK");			String[] data = null;			if (line.contains(quotes))	{  				data = splitUp(line); 				log.fine("Data has Quotes - "+data);			}							else				data = line.split(comma);						 			if (!existedUpdate(model,SQLcols,data)){					boolean orgcol = false;				StringBuilder insertcols = new StringBuilder("INSERT INTO "+model+" (AD_Client_ID,IsActive,Created,CreatedBy,Updated,UpdatedBy,"+(colname!=null?model+"_ID,":""));				StringBuilder insertvals = new StringBuilder(m.getAD_Client_ID()+comma+"'Y','"+m.getCreated()+"'"+comma+m.getCreatedBy()+comma+"'"+m.getUpdated()+"'"+comma+m.getUpdatedBy()+comma+(colname!=null?REC_ID+comma:""));				int min = SQLcols.size()<data.length?SQLcols.size():data.length;; 				if (min!=data.length)					log.warning("Cols and Data Set different size!"); 				if (clazz!=null && !tableHasSequence.getEntityType().equals(MEntityType.ENTITYTYPE_UserMaintained)) {					po = tableHasSequence.getPO(0, trxName); 				}									for (int i=0;i<min;i++){					//if _ID type, lookup Name value 					int lookupid = 0;					if (SQLcols.get(i).endsWith("_ID")){						lookupid = doLookupID(SQLcols, data, i);						if (SQLcols.get(i).equals(MColumn.COLUMNNAME_AD_Org_ID))							orgcol=true;					}						String value = data[i].trim();					if (po!=null){												MColumn col = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?) AND "+MColumn.COLUMNNAME_AD_Table_ID+"=?",trxName)								.setParameters(SQLcols.get(i).trim(),tableHasSequence.get_ID())								.first();						if (col.getAD_Reference_ID()==15 || col.getAD_Reference_ID()==16){							StringBuilder date = new StringBuilder(value);							if (date.length()<12)								date = date.append(" 00:00:00");							po.set_ValueOfColumn(col.getColumnName(),Timestamp.valueOf(date.toString()));						}						else if (col.getAD_Reference_ID()==12 ||col.getAD_Reference_ID()==29 || col.getAD_Reference_ID()==22 || col.getAD_Reference_ID()==37){							po.set_ValueOfColumn(col.getColumnName(),new BigDecimal(value));						} 						else							po.set_ValueOfColumn(SQLcols.get(i), SQLcols.get(i).endsWith("_ID")?lookupid:value);;											}else {						insertcols.append(SQLcols.get(i)+comma);						insertvals.append(SQLcols.get(i).endsWith("_ID")?lookupid+comma:"'"+value+"'"+comma); 					}				}				insertvals = new StringBuilder(insertvals.toString().replace("\"", ""));				log.fine(insertvals.toString());				if (!orgcol){					insertcols.append(MColumn.COLUMNNAME_AD_Org_ID+comma);					insertvals.append(m.getAD_Org_ID()+comma);				}				if (po!=null){ 					try {						po.saveEx(trxName);					} catch (AdempiereException e) {						e.getMessage();					}							cnt++;					log.info("DATABASE INSERT "+cnt);				}else{					if (insertcols.toString().endsWith(comma))						insertcols.deleteCharAt(insertcols.length()-1);					if (insertvals.toString().endsWith(comma))						insertvals.deleteCharAt(insertvals.length()-1);					cnt = notExistInsert(cnt, insertcols, insertvals);				} 			}		}		System.out.print("RECORDS INSERTED: "+cnt+" RECORDS UPDATED: "+updated+"\n");		return cnt;	} 		String WHERE = "";	private boolean existedUpdate(String tablename, ArrayList<String> SQLcols, String[] data) {		int lookupid=0;		int lookupid2 = 0;		if (SQLcols.get(0).endsWith("_ID")){			lookupid = doLookupID(SQLcols, data, 0);		}		if (SQLcols.get(1).endsWith("_ID")){			lookupid2 = doLookupID(SQLcols, data, 1);		}		WHERE = " WHERE "+SQLcols.get(0)+"="+(SQLcols.get(0).endsWith("_ID")?lookupid:"'"+data[0]+"'")+" AND "						 +SQLcols.get(1)+"="+(SQLcols.get(1).endsWith("_ID")?lookupid2:"'"+data[1]+"'");		int r = DB.getSQLValue(trxName,"SELECT count(*) FROM "+model+" "+WHERE+" AND AD_Client_ID="+Env.getAD_Client_ID(Env.getCtx()));		 		if (r>0){			if (m.getHelp()==null || m.getHelp().isEmpty()){//as a secret marker to say if it exist 				log.info("EXISTED NOT UPDATED: "+tablename);				log.fine("EXISTED NOT UPDATED: "+WHERE);				return true; //do not INSERT. Otherwise UPDATE			}		}else			return false;//do INSERT as not existed 		StringBuilder set = new StringBuilder("UPDATE "+tablename+" SET "); 		int min = SQLcols.size()<data.length?SQLcols.size():data.length;		if (SQLcols.contains("Name")){			for (int i=0;i<min;i++){ 				if (SQLcols.get(i).equals("Name")) {					WHERE=" WHERE Name='"+data[i]+"'";				}				else{					if (SQLcols.get(i).endsWith("_ID")){						lookupid = doLookupID(SQLcols, data, i);					}					set.append(SQLcols.get(i).endsWith("_ID")?SQLcols.get(i)+"="+lookupid+",":SQLcols.get(i)+"='"+data[i]+"',");				} 			}		}else { 			for (int i=2;i<min;i++){ 				if (SQLcols.get(i).endsWith("_ID")){					lookupid = doLookupID(SQLcols, data, i);				} 				set.append(SQLcols.get(i).endsWith("_ID")?SQLcols.get(i)+"="+lookupid+",":SQLcols.get(i)+"='"+data[i]+"',");				set = new StringBuilder(set.toString().replace("\"", ""));			}						}	 		try {			if (set.toString().endsWith(comma))				set.deleteCharAt(set.length()-1);			r = DB.executeUpdateEx(set.append(WHERE).toString(), trxName);		 			if (r==1){				updated++;					log.info("DATABASE UPDATE "+updated);				log.fine("DATABASE UPDATE "+updated+" "+set.toString());				return true;				}			 return false;           } catch (DBException e) {               e.printStackTrace();               System.out.print(set.toString());           }		return false; 	}	private int notExistInsert(int cnt, StringBuilder insertcols, StringBuilder insertvals) {		insertvals = new StringBuilder(insertvals.toString()); 		int r = DB.executeUpdateEx(insertcols.toString()+") VALUES ("+insertvals.toString()+")", trxName);		cnt++;		log.info("DATABASE INSERT "+cnt);		log.fine("DATABASE INSERT "+cnt+" "+insertcols.toString()+" VALUES="+insertvals.toString());		return cnt;	}		private int doLookupID(ArrayList<String> SQLcols, String[] data, int i) {		int lookupid;		String lookupname = SQLcols.get(i).substring(0, SQLcols.get(i).length()-3);		MTable table = new Query(Env.getCtx(),MTable.Table_Name,MTable.COLUMNNAME_TableName+"=?",trxName)				.setParameters(lookupname).first();		//if LookUpName Table does not exist, then Search its Reference		if (table==null){			MColumn column = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?)",trxName)					.setParameters(lookupname+"_ID")					.first();			if (column==null)				throw new AdempiereException("No such Column - "+lookupname);			X_AD_Reference reference = new Query(Env.getCtx(),X_AD_Reference.Table_Name,X_AD_Reference.COLUMNNAME_AD_Reference_ID+"=?",trxName)					.setParameters(column.getAD_Reference_Value_ID()).first();			if (reference==null)				throw new AdempiereException("No Reference for Column - "+lookupname);			X_AD_Ref_Table reftable =  new Query(Env.getCtx(),X_AD_Ref_Table.Table_Name,X_AD_Ref_Table.COLUMNNAME_AD_Reference_ID+"=?",trxName)					.setParameters(reference.getAD_Reference_ID()).first();			MColumn keycol = new MColumn(Env.getCtx(),reftable.getAD_Key(),trxName);			lookupname = keycol.getColumnName();			if (lookupname.endsWith("_ID"))				lookupname = lookupname.substring(0, lookupname.length()-3);			else				throw new AdempiereException("NO ID column for Ref Key: "+lookupname);		} else {			//handle parent line case to pass DocumentNo			if (model.toUpperCase().endsWith("LINE") && model.toUpperCase().substring(0, model.length()-4).equals(lookupname.toUpperCase())){ //i.e. C_Order(line) = C_Order				String query = "SELECT "+SQLcols.get(i)+" FROM "+model.substring(0, model.length()-4)+" WHERE DocumentNo='"+data[i]+"'"; //SELECT C_Order_ID FROM C_order WHERE DocumentNo = 'data[i]'"				int parentid =  DB.getSQLValue(trxName,query);			if (parentid>1)				return parentid;				else 				log.warning("Master-MasterLine with NO DocumentNo");			}						MColumn colname = new Query(Env.getCtx(),MColumn.Table_Name,MColumn.COLUMNNAME_ColumnName+"=? AND "+MColumn.COLUMNNAME_AD_Table_ID+"=?",trxName)					.setParameters("Name",table.get_ID())					.first();			log.fine("COLNAME:"+colname+" Table:"+table);			if (colname==null)				return Integer.parseInt(data[i]);		} 		String checksystem = "SELECT "+lookupname+"_ID"+" FROM "+lookupname+" WHERE Name='"+data[i]+"' AND AD_Client_ID =0";		lookupid = DB.getSQLValue(trxName,checksystem);		log.fine(checksystem);		if (lookupid<0){			String sqlvalue = "SELECT "+lookupname+"_ID"+" FROM "+lookupname+" WHERE Name='"+data[i]+"' AND AD_Client_ID ="+Env.getAD_Client_ID(Env.getCtx());			lookupid = DB.getSQLValue(trxName,sqlvalue);			log.fine(sqlvalue);		}		log.fine("LOOKUP:"+lookupname+"= "+data[i]);		if (lookupid<0) 			throw new AdempiereException("LOOKUP "+lookupname+" > Name Does Not Exist = "+data[i]+" in Client - "+Env.getAD_Client_ID(Env.getCtx()));		return lookupid;	}	private String getAttachment() { 		MAttachment attachment = m.getAttachment();		if (attachment == null) {			return "Please attach CSV File before running the process";		}		MAttachmentEntry entry = attachment.getEntry(0);		if (entry == null) {			return "NO CSV ATTACHED";		}		// Check filename is .csv		filename = entry.getFile();		log.info("Attached File Name->" + filename);				return "";	}		private void attachMenuTree(MMenu menu) {		MTree_Base menutree =  new MTree_Base(Env.getCtx(),10,trxName); 		MRO_ModelHeader header = m.getHeader();		MMenu parent = header.createMenuSummaryLevel();		X_AD_TreeNodeMM mm = new Query(Env.getCtx(),MTree_NodeMM.Table_Name,MTree_NodeMM.COLUMNNAME_AD_Tree_ID+"=? AND "+MTree_NodeMM.COLUMNNAME_Node_ID+"=?",trxName)		.setParameters(menutree.get_ID(),menu.get_ID())		.first();		if (mm != null){			mm.setParent_ID(parent.get_ID());			mm.setAD_Org_ID(0);			mm.saveEx(trxName);		}	}
}
