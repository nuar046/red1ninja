/*** Licensed under the KARMA v.1 Law of Sharing. As others have shared freely to you, so shall you share freely back to us.* If you shall try to cheat and find a loophole in this license, then KARMA will exact your share,* and your worldly gain shall come to naught and those who share shall gain eventually above you.* In compliance with previous GPLv2.0 works of Jorg Janke, Low Heng Sin, Carlos Ruiz and contributors.* This Module Creator is an idea put together and coded by Redhuan D. Oon (red1@red1.org)*/package org.ninja.process;
 import java.io.FileInputStream; import java.io.IOException;import java.math.BigDecimal;import java.sql.Timestamp;import java.util.ArrayList;import java.util.Iterator; import org.adempiere.exceptions.AdempiereException;import org.adempiere.exceptions.DBException;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormatter;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.CellType;import org.compiere.model.MColumn; import org.compiere.model.MSequence;import org.compiere.model.MTable;import org.compiere.model.PO;import org.compiere.model.Query;import org.compiere.model.X_AD_Ref_Table;import org.compiere.model.X_AD_Reference;import org.compiere.process.ProcessInfoParameter;
import org.compiere.process.SvrProcess;import org.compiere.util.DB;import org.compiere.util.Env;

	public class MigrateExcelData extends SvrProcess {
	private boolean IsActive = false;	private String File_Directory = "";	private boolean Processed = false;	private final String comma = ","; 
	private Timestamp Today = new Timestamp(System.currentTimeMillis());	private int AD_User_ID = 0;	private int AD_Client_ID = 0;	private int AD_Org_ID = 0;	private int cnt = 0; 	private int cellcnt = 0;	HSSFWorkbook workbook = null;    String[] lookupAlt = new String[5];    String[] columnAlt=new String[5];    String WhereClause = "";	int updated = 0;    String TableName = "";		protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("IsActive")){
					IsActive = "Y".equals(p.getParameter());
			}
				else if(name.equals("Processed")){
					Processed = "Y".equals(p.getParameter());
			}	else if(name.equals("File_Directory")){				File_Directory = (String)p.getParameter();			} 				else if(name.equals("WhereClause")){				WhereClause = (String)p.getParameter();		}
		}
	}
	protected String doIt() throws IOException {		AD_User_ID = Env.getAD_User_ID(getCtx());		AD_Client_ID = Env.getAD_Client_ID(getCtx());		AD_Org_ID = Env.getAD_Org_ID(getCtx());				FileInputStream file = new FileInputStream(File_Directory);  		 workbook = new HSSFWorkbook(file); 				String message = "No worksheets : "+workbook.getNumberOfSheets();					for (int i=0;i<workbook.getNumberOfSheets();i++) {			HSSFSheet sheet = workbook.getSheetAt(i);			String sheetName = sheet.getSheetName();							if (Processed)				sheetName = sheetName.substring(2); 			if (doesNotExist(sheetName)) {				System.out.println(sheetName+" does not exist. Bypassing..");				continue;			}			System.out.println("Processing..."+sheetName);  			message = message+migrateSheetToDB(sheetName,sheet,MTable.getTable_ID(sheetName)); 		} 		workbook.close();
		return message;
	}	private boolean doesNotExist(String sheetName) {		if (MTable.getTable_ID(sheetName)>0)			return false;		return true;	}	/**	 * 	 * @param sheet	 * @param Table_ID	 */	private String migrateSheetToDB(String TableName, HSSFSheet sheet, int Table_ID) {		cnt=0;		HSSFDataFormatter dataFormatter = new HSSFDataFormatter();		//AD Table characteristics 		String REC_ID = null; 		MSequence seq = null;				MTable tableHasSequence = new Query(Env.getCtx(),MTable.Table_Name,"UPPER("+MTable.COLUMNNAME_TableName+")=UPPER(?)",get_TrxName())				.setParameters(TableName).first();		PO po =null;  		Class<? extends PO> clazz = null;		if (tableHasSequence!=null){			clazz = tableHasSequence.getClass();			seq = MSequence.get(Env.getCtx(), TableName);			if (seq!=null)				REC_ID = "nextIDFunc("+seq.getAD_Sequence_ID()+", 'N') ";		}else			throw new AdempiereException("Table has no Sequence. Has it been created first in AD?");				MColumn keycolumn = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?) AND "				+MColumn.COLUMNNAME_AD_Table_ID+"=?",get_TrxName())				.setParameters(TableName+"_ID",tableHasSequence.get_ID())				.first();				ArrayList <String> SQLcols = new ArrayList<String>();				ArrayList <String> data = new ArrayList<String>();		 		Iterator rowIterator = sheet.rowIterator(); 				//get first row of ColumnNames from Sheet Table				if (rowIterator.hasNext()) {  			HSSFRow row = (HSSFRow)rowIterator.next();							Iterator cellIterator = row.cellIterator();	     			while (cellIterator.hasNext()) {	              				HSSFCell cell = (HSSFCell)cellIterator.next();				if (cell==null)					break;	            String columnName = dataFormatter.formatCellValue(cell);  	            if (columnName.isBlank())	            	break;	            int cellInteger = 0;	            if(cell.getCellType() == CellType.FORMULA) {	            	log.fine("Formula is " + cell.getCellFormula());	            	switch(cell.getCachedFormulaResultType()) {                    	case NUMERIC:                    		columnName= Double.toString(cell.getNumericCellValue());                    		break;                    	case STRING:                    		columnName= cell.getRichStringCellValue().getString();                    		break;                }            } 	             	        String[] splitColumnName = columnName.split(">");	        if (splitColumnName.length>1) {	        	columnName = splitColumnName[0];	        	columnAlt[cellcnt] = splitColumnName[0];	        	lookupAlt[cellcnt] = splitColumnName[1];	        	cellcnt++;	        }            if (MColumn.getColumn_ID(TableName, columnName)>0) {		       //set column to SQL Cols		       SQLcols.add(columnName);		        	  		       }else 		           throw new AdempiereException("No such column. Check your Excel sheet+column:"+TableName+"-"+columnName);          			}		} else			return "No rows in Excel Sheet";		//get each row of values to write to its Sheet Table.				while (rowIterator.hasNext()) { 			HSSFRow row = (HSSFRow) rowIterator.next();			//get a new PO instance for each row / record			if (clazz!=null ) {//&& !tableHasSequence.getEntityType().equals(MEntityType.ENTITYTYPE_UserMaintained)) {				po = tableHasSequence.getPO(0, get_TrxName()); 			}			Iterator cellIterator = row.cellIterator();	     			while (cellIterator.hasNext()) {	              HSSFCell cell = (HSSFCell) cellIterator.next();	              String cellValue = dataFormatter.formatCellValue(cell); 	              int cellInteger = 0;	              if(cell.getCellType() == CellType.FORMULA) {	                  log.fine("Formula is " + cell.getCellFormula()); 	                  switch(cell.getCachedFormulaResultType()) {	                      case NUMERIC:	                          cellValue= Double.toString(cell.getNumericCellValue());	                          break;	                      case STRING:	                          cellValue= cell.getRichStringCellValue().getString();	                          break;	                  }	              }   	              //row set of cellValues    	              if (cellValue.isBlank() && SQLcols.size()==data.size())	            	  continue;//trailing spaces end of row column	              data.add(cellValue);	        }			//check same INSERT pairs			if (SQLcols.size()!=data.size()) {				System.out.println("INSERT pair unequal: "+SQLcols+" DATA:"+data);				if (data.isEmpty() || data.size()==0)					return "("+TableName+" = "+cnt+" records) HAS EMPTY ROWS";//throw new AdempiereException("INSERT pair unequal");				throw new AdempiereException("INSERT pair unequal: "+SQLcols+" DATA:"+data);			}			//Build INSERT/UPDATE statement with 7 mandatory			//UPDATE overwrite?			if (IsActive)				updateIsActive(TableName,SQLcols,data);			else				insertWithPO(po, tableHasSequence, REC_ID, keycolumn, TableName,SQLcols,data);			data.clear(); 		}			return "("+TableName+" = "+cnt+" records) ";	}	private void insertWithPO(PO po, PO tableHasSequence, String REC_ID, MColumn keycolumn, String TableName, ArrayList<String> SQLcols, ArrayList<String> data) {		StringBuilder insertcols = new StringBuilder("INSERT INTO "+TableName+" (AD_Client_ID,IsActive,Created,CreatedBy,Updated,UpdatedBy,"+(keycolumn!=null?TableName+"_ID,":""));		StringBuilder insertvals = new StringBuilder(AD_Client_ID+comma+"'Y','"+Today+"'"+comma+AD_User_ID+comma+"'"+Today+"'"+comma+AD_User_ID+comma+(keycolumn!=null?REC_ID+comma:""));		int min = SQLcols.size();  		boolean orgcol = false;		cellcnt = 0;		for (int i=0;i<min;i++){			//if _ID type, lookup Name value 			int lookupid = 0;			if (SQLcols.get(i).endsWith("_ID")){				lookupid = doLookupID(SQLcols, data, i);				if (lookupid==0) //ERROR - BYPASS THIS COL. IT SHALL BE BLANK. HOUSEKEEPING TASK					continue;				if (SQLcols.get(i).equals(MColumn.COLUMNNAME_AD_Org_ID))					orgcol=true;			}				String value = data.get(i);			if (po!=null){								MColumn col = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?) AND "+MColumn.COLUMNNAME_AD_Table_ID+"=?",get_TrxName())						.setParameters(SQLcols.get(i).trim(),tableHasSequence.get_ID())						.first();				if (col.getAD_Reference_ID()==15 || col.getAD_Reference_ID()==16){					StringBuilder date = new StringBuilder(value);					if (date.length()<12)						date = date.append(" 00:00:00");					po.set_ValueOfColumn(col.getColumnName(),Timestamp.valueOf(date.toString()));				}				else if (col.getAD_Reference_ID()==12 ||col.getAD_Reference_ID()==29 || col.getAD_Reference_ID()==22 || col.getAD_Reference_ID()==37){					po.set_ValueOfColumn(col.getColumnName(),new BigDecimal(value));				} 				else					po.set_ValueOfColumn(SQLcols.get(i), SQLcols.get(i).endsWith("_ID")?lookupid:value);							}else {				insertcols.append(SQLcols.get(i)+comma);				insertvals.append(SQLcols.get(i).endsWith("_ID")?lookupid+comma:"'"+value+"'"+comma); 			} 		}		log.fine(insertvals.toString());		if (!orgcol){			insertcols.append(MColumn.COLUMNNAME_AD_Org_ID+comma);			insertvals.append(AD_Org_ID+comma);		}		if (po!=null){  							if (!po.save(get_TrxName())) {				String e = new AdempiereException().toString();			 		System.out.println(e);			 		statusUpdate(e);			} else { 				cnt++;				log.info("DATABASE INSERT "+cnt);				//Status Update Display on Screen				statusUpdate("Processing : "+TableName+"::"+cnt);			}		}else{ 				if (insertcols.toString().endsWith(comma))					insertcols.deleteCharAt(insertcols.length()-1);				if (insertvals.toString().endsWith(comma))					insertvals.deleteCharAt(insertvals.length()-1);				cnt = insertWithoutPO(cnt, insertcols, insertvals);		} 	}	private int insertWithoutPO(int cnt2, StringBuilder insertcols, StringBuilder insertvals) {		throw new AdempiereException("END OF RAILLINE!");//TODO IF VALID		//return 0;	}	/**	 * First 2 columns act as Index Key. Please review 2 columns of your source XLS must be unique.	 * @param REC_ID	 * @param keycolumn	 * @param TableName	 * @param SQLcols	 * @param data	 */	private void updateIsActive(String table, ArrayList<String> SQLcols, ArrayList<String> data) {		String WHERE = "";		this.TableName=table;		cellcnt = 0; 		int lookupid=0;		int lookupid2 = 0;		if (SQLcols.get(0).endsWith("_ID")){			lookupid = doLookupID(SQLcols, data, 0);		}		if (SQLcols.get(1).endsWith("_ID")){			lookupid2 = doLookupID(SQLcols, data, 1);		}		WHERE = " WHERE "+SQLcols.get(0)+"="+(SQLcols.get(0).endsWith("_ID")?lookupid:"'"+data.get(0)+"'")+" AND "						 +SQLcols.get(1)+"="+(SQLcols.get(1).endsWith("_ID")?lookupid2:"'"+data.get(1)+"'");		int r = DB.getSQLValue(get_TrxName(),"SELECT count(*) FROM "+TableName+" "+WHERE+" AND AD_Client_ID="+Env.getAD_Client_ID(Env.getCtx()));		 				StringBuilder set = new StringBuilder("UPDATE "+TableName+" SET "); 		int min = SQLcols.size()<data.size()?SQLcols.size():data.size();					for (int i=2;i<min;i++){ 				String hold = "";				if (SQLcols.get(i).endsWith("_ID")){					lookupid = doLookupID(SQLcols, data, i);				}				if (SQLcols.get(i).endsWith("_ID"))					hold = SQLcols.get(i)+"="+lookupid+",";				else {  					if (isNumeric(data.get(i)))						hold=SQLcols.get(i)+"="+data.get(i)+",";					else						hold=SQLcols.get(i)+"='"+data.get(i)+"',";				}				set.append(hold);				set = new StringBuilder(set.toString().replace("\"", ""));			}	 		try {			if (set.toString().endsWith(comma))				set.deleteCharAt(set.length()-1);			r = DB.executeUpdateEx(set.append(WHERE).toString()+(" AND "+WhereClause).toString(), get_TrxName());		 			if (r==1){				updated++;					statusUpdate("Updating : "+TableName+"::"+updated); 				System.out.println("DATABASE UPDATE "+updated+" "+set.toString()+" AND "+WhereClause);				}            } catch (DBException e) {               e.printStackTrace();               System.out.print(set.toString());           }				cnt=updated;	}	private static boolean isNumeric(String strNum) {	    try {	        double d = Double.parseDouble(strNum);	    } catch (NumberFormatException | NullPointerException nfe) {	        return false;	    }	    return true;	}	private int doLookupID(ArrayList<String> SQLcols, ArrayList<String> data, int i) {		int lookupid;		String lookupname = SQLcols.get(i).substring(0, SQLcols.get(i).length()-3);		MTable table = new Query(Env.getCtx(),MTable.Table_Name,MTable.COLUMNNAME_TableName+"=?",get_TrxName())				.setParameters(lookupname).first();		//if LookUpName Table does not exist, then Search its Reference		if (table==null){			MColumn column = new Query(Env.getCtx(),MColumn.Table_Name,"UPPER("+MColumn.COLUMNNAME_ColumnName+")=UPPER(?)",get_TrxName())					.setParameters(lookupname+"_ID")					.first();			if (column==null)				throw new AdempiereException("No such Column - "+lookupname);			X_AD_Reference reference = new Query(Env.getCtx(),X_AD_Reference.Table_Name,X_AD_Reference.COLUMNNAME_AD_Reference_ID+"=?",get_TrxName())					.setParameters(column.getAD_Reference_Value_ID()).first();			if (reference==null)				throw new AdempiereException("No Reference for Column - "+lookupname);			X_AD_Ref_Table reftable =  new Query(Env.getCtx(),X_AD_Ref_Table.Table_Name,X_AD_Ref_Table.COLUMNNAME_AD_Reference_ID+"=?",get_TrxName())					.setParameters(reference.getAD_Reference_ID()).first();			MColumn keycol = new MColumn(Env.getCtx(),reftable.getAD_Key(),get_TrxName());			lookupname = keycol.getColumnName();			if (lookupname.endsWith("_ID"))				lookupname = lookupname.substring(0, lookupname.length()-3);			else				throw new AdempiereException("NO ID column for Ref Key: "+lookupname);		} else {			//handle parent line case to pass DocumentNo			if (TableName.toUpperCase().endsWith("LINE") && TableName.toUpperCase().substring(0, TableName.length()-4).equals(lookupname.toUpperCase())){ //i.e. C_Order(line) = C_Order				String query = "SELECT "+SQLcols.get(i)+" FROM "+TableName.substring(0, TableName.length()-4)+" WHERE DocumentNo='"+data.get(i)+"'"; //SELECT C_Order_ID FROM C_order WHERE DocumentNo = 'data.get(i)'"				int parentid =  DB.getSQLValue(get_TrxName(),query);				if (parentid>1)					return parentid;					else 					log.warning("Master-MasterLine with NO DocumentNo");			}			//************************************************************************************************************			//Check if using AlterLookUp ">" or Table has a column 'Name' or else return PK or else use Alternate Lookup > 			if (SQLcols.get(i)==columnAlt[cellcnt]) {				//*******************************************************				//Check lookup nested 1 level only. For example: C_BPartner_Location_ID>C_BPartner_ID				if (lookupAlt[cellcnt].endsWith("_ID")) { //mini lookup  C_BPartner_ID 					MTable temp = new Query(Env.getCtx(),MTable.Table_Name,MTable.COLUMNNAME_TableName+"=?",get_TrxName())							.setParameters(lookupAlt[cellcnt].substring(0, lookupAlt[cellcnt].length()-3)) //lookup=C_BPartner table							.first();					if (temp==null)						throw new AdempiereException("Lookup within table not found: "+SQLcols.get(i));					//Select C_BPartnerLocation_ID from C_BPartnerLocation  					String within = "SELECT "+temp.getTableName()+"_ID FROM "+temp.getTableName()+" WHERE Name='"+data.get(i)+"'";					int internal = DB.getSQLValue(get_TrxName(),within); 										String withinLookUpSQL = "SELECT "+lookupname+"_ID FROM "+lookupname+" WHERE "+lookupAlt[cellcnt]+"="+internal;					lookupid = DB.getSQLValue(get_TrxName(),withinLookUpSQL);										if (lookupid<0)						throw new AdempiereException("Lookup within record not found: "+lookupAlt[cellcnt]+":"+internal);					return lookupid;				}//********************************************************								//SELECT C_Location_ID FROM C_Location WHERE Address1 = '**';				String altLookUpSQL = "SELECT "+lookupname+"_ID FROM "+lookupname+" WHERE "+lookupAlt[cellcnt]+"='"+data.get(i)+"'";				lookupid = DB.getSQLValue(get_TrxName(),altLookUpSQL); 				cellcnt++;				if (lookupid<0) {					System.out.println("Cannot do alternative cell lookup ID with "+altLookUpSQL);					log.warning("Cannot do alternative cell lookup ID with "+altLookUpSQL);					return 0;				}				else return lookupid; //Alternative Look Up ID ends here 			//************************************************************************************************************							}else {  //qualify that the Lookup_ID refers to Name in Lookup Table.				MColumn colname = new Query(Env.getCtx(),MColumn.Table_Name,MColumn.COLUMNNAME_ColumnName+"=? AND "+MColumn.COLUMNNAME_AD_Table_ID+"=?",get_TrxName())						.setParameters("Name",table.get_ID())						.first();				log.fine("COLNAME:"+colname+" Table:"+table);				if (colname==null) {					//check if data is Integer and pass exactly					try {						return Integer.parseInt(data.get(i));					} catch (NumberFormatException e) {						throw new AdempiereException(table.getName()+" "+data.get(i) +" ** No Name in ID Lookup - Try Alternate 'Table_ID>AlternateColumnName' in header column");					}				}			} 		} 		String checksystem = "SELECT "+lookupname+"_ID"+" FROM "+lookupname+" WHERE Name='"+data.get(i)+"' AND AD_Client_ID =0";		lookupid = DB.getSQLValue(get_TrxName(),checksystem);		log.fine(checksystem);		if (lookupid<0){			String sqlvalue = "SELECT "+lookupname+"_ID"+" FROM "+lookupname+" WHERE Name='"+data.get(i)+"' AND AD_Client_ID ="+AD_Client_ID;			lookupid = DB.getSQLValue(get_TrxName(),sqlvalue);			log.fine(sqlvalue);		}		log.fine("LOOKUP:"+lookupname+"= "+data.get(i));		if (lookupid<0) 			throw new AdempiereException(TableName+ "Table LOOKUP "+lookupname+" > Name Does Not Exist = "+data.get(i)+" in Client - "+AD_Client_ID+" DUMP DATA:"+data);		return lookupid;	}
}
