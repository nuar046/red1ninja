/*** Licensed under the KARMA v.1 Law of Sharing. As others have shared freely to you, so shall you share freely back to us.* If you shall try to cheat and find a loophole in this license, then KARMA will exact your share,* and your worldly gain shall come to naught and those who share shall gain eventually above you.* In compliance with previous GPLv2.0 works of Jorg Janke, Low Heng Sin, Carlos Ruiz and contributors.* This Module Creator is an idea put together and coded by Redhuan D. Oon (red1@red1.org)*/package org.ninja.process;
import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.logging.Level;import org.adempiere.process.UUIDGenerator;import org.compiere.model.MColumn;import org.compiere.model.MProductCategory;import org.compiere.model.PO;import org.compiere.model.Query;import org.compiere.process.ProcessInfoParameter;import org.compiere.process.SvrProcess;import org.compiere.util.DB;import org.compiere.util.Env;

	public class ProductAccts extends SvrProcess {
	private int M_Product_Category_ID = 0;
	protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("M_Product_Category_ID")){
					M_Product_Category_ID = p.getParameterAsInt();
			}
		}
	}
	protected String doIt() {		MProductCategory po = new Query(Env.getCtx(),MProductCategory.Table_Name,MProductCategory.COLUMNNAME_M_Product_Category_ID+"=?",get_TrxName())				.setParameters(M_Product_Category_ID).first();		insert_Accounting(po,"M_Product_Category_Acct", "C_AcctSchema_Default", null); 
		return "Product Category Accounts Inserted";
	}		/**	 * 	Insert Accounting Records (taken by RED1 from PO.java)	 *	@param acctTable accounting sub table	 *	@param acctBaseTable acct table to get data from	 *	@param whereClause optional where clause with alias "p" for acctBaseTable	 *	@return true if records inserted	 */	private ArrayList <String>	s_acctColumns = null;		private boolean insert_Accounting (MProductCategory po, String acctTable,		String acctBaseTable, String whereClause)	{		if (s_acctColumns == null	//	cannot cache C_BP_*_Acct as there are 3			|| acctTable.startsWith("C_BP_"))		{			s_acctColumns = new ArrayList<String>();			String sql = "SELECT c.ColumnName "				+ "FROM AD_Column c INNER JOIN AD_Table t ON (c.AD_Table_ID=t.AD_Table_ID) "				+ "WHERE t.TableName=? AND c.IsActive='Y' AND c.AD_Reference_ID=25 ORDER BY c.ColumnName";			PreparedStatement pstmt = null;			ResultSet rs = null;			try			{				pstmt = DB.prepareStatement (sql, null);				pstmt.setString (1, acctTable);				rs = pstmt.executeQuery ();				while (rs.next ())					s_acctColumns.add (rs.getString(1));			}			catch (Exception e)			{				log.log(Level.SEVERE, acctTable, e);			}			finally {				DB.close(rs, pstmt);				rs = null; pstmt = null;			}			if (s_acctColumns.size() == 0)			{				log.severe ("No Columns for " + acctTable);				return false;			}		}		//	Create SQL Statement - INSERT		StringBuilder sb = new StringBuilder("INSERT INTO ")			.append(acctTable)			.append(" (").append(MProductCategory.Table_Name)			.append("_ID, C_AcctSchema_ID, AD_Client_ID,AD_Org_ID,IsActive, Created,CreatedBy,Updated,UpdatedBy ");		for (int i = 0; i < s_acctColumns.size(); i++)			sb.append(",").append(s_acctColumns.get(i));		//check whether db have working generate_uuid function.		boolean uuidFunction = DB.isGenerateUUIDSupported();		//uuid column		int uuidColumnId = DB.getSQLValue(get_TrxName(), "SELECT col.AD_Column_ID FROM AD_Column col INNER JOIN AD_Table tbl ON col.AD_Table_ID = tbl.AD_Table_ID WHERE tbl.TableName=? AND col.ColumnName=?",				acctTable, PO.getUUIDColumnName(acctTable));		if (uuidColumnId > 0 && uuidFunction)			sb.append(",").append(PO.getUUIDColumnName(acctTable));		//	..	SELECT		sb.append(") SELECT ").append(po.get_ID())			.append(", p.C_AcctSchema_ID, p.AD_Client_ID,0,'Y', SysDate,")			.append(po.getUpdatedBy()).append(",SysDate,").append(po.getUpdatedBy());		for (int i = 0; i < s_acctColumns.size(); i++)			sb.append(",p.").append(s_acctColumns.get(i));		//uuid column		if (uuidColumnId > 0 && uuidFunction)			sb.append(",generate_uuid()");		//	.. 	FROM		sb.append(" FROM ").append(acctBaseTable)			.append(" p WHERE p.AD_Client_ID=").append(getAD_Client_ID());		if (whereClause != null && whereClause.length() > 0)			sb.append (" AND ").append(whereClause);		sb.append(" AND NOT EXISTS (SELECT * FROM ").append(acctTable)			.append(" e WHERE e.C_AcctSchema_ID=p.C_AcctSchema_ID AND e.")			.append(MProductCategory.Table_Name).append("_ID=").append(po.get_ID()).append(")");		//		int no = DB.executeUpdate(sb.toString(), get_TrxName());		if (no > 0) {			if (log.isLoggable(Level.FINE)) log.fine("#" + no);		} else {			log.warning("#" + no					+ " - Table=" + acctTable + " from " + acctBaseTable);		}		//fall back to the slow java client update code		if (uuidColumnId > 0 && !uuidFunction) {			MColumn column = new MColumn(getCtx(), uuidColumnId, get_TrxName());			UUIDGenerator.updateUUID(column, get_TrxName());		}		return no > 0;	}	//	insert_Accounting
}
